"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpacityVariant = exports.ColorVariant = exports.CustomVariant = exports.VariantType = exports.ColorScheme = exports.VariableColor = exports.Color = void 0;
const tinycolor_1 = require("@ctrl/tinycolor");
const lodash_1 = __importDefault(require("lodash"));
class Color {
    /**
     * Creates a color.
     */
    constructor(name, value) {
        this.setName(name);
        this.setValue(value);
    }
    /**
     * Gets the color's name.
     */
    getName() {
        return this._name;
    }
    /**
     * Sets the color's name.
     */
    setName(name) {
        this._name = name;
        return this;
    }
    /**
     * Get the computed color value.
     */
    getValue() {
        return this._computed;
    }
    /**
     * Set the color.
     */
    setValue(value) {
        this._value = value;
        this._computed = new tinycolor_1.TinyColor(value);
        return this;
    }
    /**
     * Gets the original value.
     */
    getOriginalValue() {
        return this._value;
    }
}
exports.Color = Color;
/**
 * A color that may be affected by multiple variants.
 */
class VariableColor extends Color {
    constructor(name, value) {
        super(name, value);
        this._variants = [];
    }
    /**
     * Adds a variant to that color.
     */
    setVariant(variant) {
        this._variants.push(variant);
        return this;
    }
    /**
     * Sets a color variant for that color.
     */
    setColorVariant(name, value) {
        this._variants.push(new ColorVariant(name, value));
        return this;
    }
    /**
     * Sets a color variant for that color.
     */
    setOpacityVariant(name, value) {
        this._variants.push(new OpacityVariant(name, value));
        return this;
    }
    /**
     * Sets a custom variant for that color.
     */
    setCustomVariant(name, transformer) {
        this._variants.push(new CustomVariant(name, transformer));
        return this;
    }
    /**
     * Gets every variants for this color.
     */
    getVariants() {
        return this._variants;
    }
    /**
     * Gets every color variant for this color.
     */
    getColorVariants() {
        return this.getVariantsByType(VariantType.Color);
    }
    /**
     * Gets every opacity variant for this color.
     */
    getOpacityVariants() {
        return this.getVariantsByType(VariantType.Opacity);
    }
    /**
     * Gets every custom variant for this color.
     */
    getCustomVariants() {
        return this.getVariantsByType(VariantType.Custom);
    }
    /**
     * Gets every variant of the specified type.
     */
    getVariantsByType(type) {
        return this._variants.filter((variant) => variant.getType() === type);
    }
    /**
     * Get the name used for the Tailwind configuration. Kebab-cased.
     */
    getTailwindConfigurationName() {
        return lodash_1.default.kebabCase(this.getName());
    }
    /**
     * Get the value used for the Tailwind configuration.
     */
    getTailwindConfigurationValue() {
        // https://github.com/tailwindcss/tailwindcss/pull/1676
        // If that PR passes, this method will instead return a closure
        // which will have an opacity variable name as a parameter,
        // so that the opacity of this color can be changed via Tailwind CSS
        // opacity utilities instead of being hardcoded in its value
        const alpha = parseFloat(this.getValue().a.toFixed(8));
        const colorVariable = `var(${this.getCssVariableName()})`;
        return `rgba(${colorVariable}, ${alpha})`;
    }
    /**
     * Get the CSS color variable name generated in the final CSS.
     */
    getCssVariableName() {
        return `--color-${this.getTailwindConfigurationName()}`;
    }
    /**
     * Get the CSS variable value used in the final CSS.
     */
    getCssVariableValue() {
        // Opacity is hard-coded to the Tailwind configuration, because
        // opacity variants exist, and if this PR passes, Tailwind's opacity
        // utilities can be used instead.
        const { r, g, b } = this.getValue();
        return `${r}, ${g}, ${b}`;
    }
}
exports.VariableColor = VariableColor;
/**
 * Represents the color schemes usable by the themes.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme
 */
var ColorScheme;
(function (ColorScheme) {
    /**
     * Indicates that the theme has no specified color scheme.
     */
    ColorScheme["Undefined"] = "no-preference";
    /**
     * Indicates that the theme is created for light themes.
     */
    ColorScheme["Light"] = "light";
    /**
     * Indicates that the theme is created for dark themes.
     */
    ColorScheme["Dark"] = "dark";
})(ColorScheme = exports.ColorScheme || (exports.ColorScheme = {}));
/**
 * Represents the possible types of variants.
 */
var VariantType;
(function (VariantType) {
    /**
     * A normal variant.
     */
    VariantType[VariantType["Custom"] = 0] = "Custom";
    /**
     * A variant that replaces the color by another.
     */
    VariantType[VariantType["Color"] = 1] = "Color";
    /**
     * A variant that changes the opacity of the color.
     */
    VariantType[VariantType["Opacity"] = 2] = "Opacity";
})(VariantType = exports.VariantType || (exports.VariantType = {}));
/**
 * A variant that replaces its color thanks to a given logic.
 */
class CustomVariant {
    /**
     * Creates a variant.
     *
     * @param {string} name The variant's name.
     * @param {VariantTransformer} transformer The method to transform the color.
     */
    constructor(name, transformer) {
        this._name = name;
        this._transformer = transformer;
    }
    getType() {
        return VariantType.Custom;
    }
    getName() {
        return this._name;
    }
    getVariantTypeName() {
        return 'custom-variant';
    }
    getTailwindConfigurationName() {
        return lodash_1.default.kebabCase(this.getName());
    }
    getCssVariableName(color) {
        const variantTypeName = this.getVariantTypeName();
        const colorName = color.getTailwindConfigurationName(); // kebab-cased name
        const variantName = this.getTailwindConfigurationName(); // kebab-case name
        return `--${variantTypeName}-${colorName}-${variantName}`;
    }
    /**
     * Gets the computed value of the color.
     */
    apply(input) {
        return this._transformer(new tinycolor_1.TinyColor(input));
    }
    /**
     * Gets an RGBA value separated by comas.
     */
    getCssVariableValue(color) {
        const { r, g, b, a } = this.apply(color.getValue());
        const alpha = parseFloat(a.toFixed(8));
        return `${r.toFixed(0)}, ${g.toFixed(0)}, ${b.toFixed(0)}, ${alpha}`;
    }
    /**
     * Gets an RGBA value with the name of this variant's variable as a parameter.
     */
    getTailwindConfigurationValue(color) {
        const variantVariable = `var(${this.getCssVariableName(color)})`;
        return `rgba(${variantVariable})`;
    }
}
exports.CustomVariant = CustomVariant;
/**
 * A variant that replaces its color by another color.
 */
class ColorVariant extends CustomVariant {
    /**
     * Creates a color variant.
     *
     * @param name This variant's name.
     * @param replacement The replacement color.
     */
    constructor(name, replacement) {
        super(name, () => new tinycolor_1.TinyColor(replacement));
        this._replacement = replacement;
    }
    getType() {
        return VariantType.Color;
    }
    getVariantTypeName() {
        return 'color-variant';
    }
    /**
     * Gets the replacement color.
     */
    getReplacement() {
        return this._replacement;
    }
}
exports.ColorVariant = ColorVariant;
/**
 * A variant that changes the opacity of its color.
 */
class OpacityVariant extends CustomVariant {
    /**
     * Creates an opacity variant.
     *
     * @param name This variant's name.
     * @param opacity The new opacity.
     */
    constructor(name, opacity) {
        super(name, (color) => new tinycolor_1.TinyColor(color).setAlpha(opacity));
        this._opacity = opacity;
    }
    getType() {
        return VariantType.Opacity;
    }
    getVariantTypeName() {
        return 'opacity-variant';
    }
    /**
     * Gets the opacity.
     */
    getOpacity() {
        return this._opacity;
    }
    /**
     * Gets an RGB value separated by comas.
     */
    getCssVariableValue(color) {
        return parseFloat(this.getOpacity().toFixed(8)).toString();
    }
    /**
     * Gets an RGBA value with the name of the color variable as
     * the first parameter and this variant's variable as the second
     */
    getTailwindConfigurationValue(color) {
        const colorVariable = `var(${color.getCssVariableName()})`;
        const opacityVariable = `var(${this.getCssVariableName(color)})`;
        return `rgba(${colorVariable}, ${opacityVariable})`;
    }
}
exports.OpacityVariant = OpacityVariant;
