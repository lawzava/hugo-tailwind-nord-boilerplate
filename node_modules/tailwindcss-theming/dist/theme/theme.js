"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Theme = exports.ThemeManager = void 0;
const color_1 = require("./color");
const flattenColorObject_1 = require("../util/flattenColorObject");
const isMappedVariant_1 = require("../util/isMappedVariant");
const variable_1 = require("./variable");
const generateTailwindConfiguration_1 = require("../util/generateTailwindConfiguration");
const generateCssConfiguration_1 = require("../util/generateCssConfiguration");
const strategy_1 = require("./strategy");
const lodash_1 = __importDefault(require("lodash"));
/**
 * The plugin's theme builder. It is an object that contains the
 * configured themes for the application, as well as other settings needed
 * to generate anything the user wants to be customized.
 */
class ThemeManager {
    /**
     * Creates a theme manager.
     */
    constructor() {
        this._themes = [];
    }
    /*
    |--------------------------------------------------------------------------
    | Default Theme Setters
    |--------------------------------------------------------------------------
    */
    /**
     * Defines the default theme for every color scheme.
     */
    setDefaultTheme(theme) {
        theme = lodash_1.default.cloneDeep(theme);
        // We can't have more than one default theme.
        if (this.getDefaultTheme()) {
            throw new Error('Tried to set a default theme, but there was already one.');
        }
        // The default theme has no color scheme.
        this._themes.push(theme.setDefault().setColorScheme(color_1.ColorScheme.Undefined));
        return this;
    }
    setDefaultLightTheme(theme) {
        theme = lodash_1.default.cloneDeep(theme);
        // We can't have more than one default light theme.
        if (this.getDefaultLightTheme()) {
            throw new Error('Tried to set a default light theme, but there was already one.');
        }
        this._themes.push(theme.setDefault().setColorScheme(color_1.ColorScheme.Light));
        return this;
    }
    setDefaultDarkTheme(theme) {
        theme = lodash_1.default.cloneDeep(theme);
        // We can't have more than one default dark theme.
        if (this.getDefaultDarkTheme()) {
            throw new Error('Tried to set a default dark theme, but there was already one.');
        }
        this._themes.push(theme.setDefault().setColorScheme(color_1.ColorScheme.Dark));
        return this;
    }
    /*
    |--------------------------------------------------------------------------
    | Other Theme Adders
    |--------------------------------------------------------------------------
    */
    /**
     * Add a theme.
     */
    addTheme(theme) {
        theme = lodash_1.default.cloneDeep(theme);
        this._themes.push(theme);
        return this;
    }
    /**
     * Add a light theme.
     */
    addLightTheme(theme) {
        theme = lodash_1.default.cloneDeep(theme);
        return this.addTheme(theme.setColorScheme(color_1.ColorScheme.Light));
    }
    /**
     * Add a dark theme.
     */
    addDarkTheme(theme) {
        theme = lodash_1.default.cloneDeep(theme);
        return this.addTheme(theme.setColorScheme(color_1.ColorScheme.Dark));
    }
    /*
    |--------------------------------------------------------------------------
    | Theme getters.
    |--------------------------------------------------------------------------
    */
    /**
     * Gets every themes.
     */
    getAllThemes() {
        return this._themes;
    }
    /**
     * Get every theme, except the default one.
     */
    getThemes() {
        return this.getThemesFor(color_1.ColorScheme.Undefined);
    }
    /**
     * Get light-schemed themes, except the default one.
     */
    getLightThemes() {
        return this.getThemesFor(color_1.ColorScheme.Light);
    }
    /**
     * Get dark-schemed themes, except the default one.
     */
    getDarkThemes() {
        return this.getThemesFor(color_1.ColorScheme.Dark);
    }
    /**
     * Gets the default theme.
     */
    getDefaultTheme() {
        return this.getDefaultThemeFor(color_1.ColorScheme.Undefined);
    }
    /**
     * Gets the default light theme.
     */
    getDefaultLightTheme() {
        return this.getDefaultThemeFor(color_1.ColorScheme.Light);
    }
    /**
     * Gets the default dark theme.
     */
    getDefaultDarkTheme() {
        return this.getDefaultThemeFor(color_1.ColorScheme.Dark);
    }
    /**
     * Gets the default theme for the given scheme.
     */
    getDefaultThemeFor(scheme) {
        return this._themes.find((theme) => theme.isDefault() && scheme === theme.getColorScheme());
    }
    /**
     * Gets all themes for the given scheme, except the default one.
     */
    getThemesFor(scheme) {
        return this._themes.filter((theme) => !theme.isDefault() && scheme === theme.getColorScheme());
    }
    /*
    |--------------------------------------------------------------------------
    | Strategy-related
    |--------------------------------------------------------------------------
    */
    /**
     * Defines the prefix used for the strategy.
     */
    setPrefix(prefix) {
        this._prefix = prefix;
        return this;
    }
    /**
     * Gets the prefix used for the strategy.
     */
    getPrefix() {
        return this._prefix;
    }
    /**
     * Defines the strategy used for theme selection.
     */
    setStrategy(strategy) {
        this._strategy = strategy;
        return this;
    }
    /**
     * Gets the strategy used for theme selection.
     */
    getStrategy() {
        return this._strategy;
    }
    /*
    |--------------------------------------------------------------------------
    | Strategies
    |--------------------------------------------------------------------------
    */
    /**
     * Each theme will be exported as a `data-theme` attribute.
     * You will be able to use a theme by setting the attribute `data-theme` with the value `<themeName>` on a node.
     * The CSS rule will be `[data-theme=<themeName>]`.
     */
    asDataThemeAttributes() {
        this.setStrategy(strategy_1.Strategy.DataThemeAttribute);
        return this;
    }
    /**
     * Each theme will be exported as a data attribute.
     * You will be able to use a theme by setting the attribute `data-<themeName>` on a node. The CSS rule will be `[data-<themeName>]`.
     */
    asDataAttributes() {
        this.setStrategy(strategy_1.Strategy.DataAttribute);
        return this;
    }
    /**
     * Each theme will be exported in a class.
     * You will be able to use a theme by applying the class `.<themeName>` on a node. The CSS rule will be `.<themeName>`.
     */
    asClasses() {
        this.setStrategy(strategy_1.Strategy.Class);
        return this;
    }
    /**
     * Each theme will be exported as an attribute with a prefix.
     * You will be able to use a theme by setting the attribute `<choosenPrefix>-<themeName>` on a node.
     * The CSS rule will be `[<choosenPrefix>-<themeName>]`.
     */
    asPrefixedAttributes(prefix = 'theme') {
        this.setStrategy(strategy_1.Strategy.PrefixedAttribute);
        this.setPrefix(prefix);
        return this;
    }
    /**
     * Each theme will be exported in a class with a prefix.
     * You will be able to use a theme by applying the class `.<choosenPrefix>-<themeName>` on a node.
     * The CSS rule will be `.<choosenPrefix>-<themeName>`.
     */
    asPrefixedClasses(prefix = 'theme') {
        this.setStrategy(strategy_1.Strategy.PrefixedClass);
        this.setPrefix(prefix);
        return this;
    }
    /*
    |--------------------------------------------------------------------------
    | Plugin
    |--------------------------------------------------------------------------
    */
    /**
     * Gets the Tailwind configuration for this theme manager.
     */
    getTailwindConfiguration() {
        return generateTailwindConfiguration_1.generateTailwindConfiguration(this);
    }
    /**
     * Gets an object that generates the themes' CSS inside the addBase helper.
     */
    getCssConfiguration() {
        return generateCssConfiguration_1.generateCssConfiguration(this);
    }
}
exports.ThemeManager = ThemeManager;
class Theme {
    /**
     * Creates a new theme.
     */
    constructor() {
        // We don't want a theme to be targetable by default.
        this._targetable = false;
        // Whether or not this theme is the default is changed by the theme
        // manager. This is still accessible to user-land but as an advanced
        // toggle.
        this._default = false;
        // By default, a theme has no specific color scheme. It's the theme
        // manager's responsibility to set one, even though the option is
        // accessible to user-land as an advanced feature.
        this._colorScheme = color_1.ColorScheme.Undefined;
        // We set the colors and variables.
        this._colors = [];
        this._variables = [];
    }
    /*
    |--------------------------------------------------------------------------
    | Name
    |--------------------------------------------------------------------------
    */
    /**
     * Defines this theme's name.
     */
    setName(name) {
        this._name = name;
        return this;
    }
    /**
     * Gets this theme's name.
     */
    getName() {
        var _a;
        return (_a = this._name) !== null && _a !== void 0 ? _a : (this.hasScheme() ? this.getColorScheme() : 'default');
    }
    /*
    |--------------------------------------------------------------------------
    | Targetable
    |--------------------------------------------------------------------------
    */
    /**
     * Defines this theme as targetable, which means it can be selected
     * with a CSS selector.
     */
    targetable() {
        this._targetable = true;
        return this;
    }
    /**
     * Defines this theme as untargetable, which means it can not be selected
     * with a CSS selector.
     */
    untargetable() {
        this._targetable = false;
        return this;
    }
    /**
     * Determines if this theme is targetable.
     */
    isTargetable() {
        return this._targetable;
    }
    /*
    |--------------------------------------------------------------------------
    | Default
    |--------------------------------------------------------------------------
    */
    /**
     * Defines whether or not this theme is the default for
     * its color scheme.
     */
    setDefault(shouldBeDefault = true) {
        this._default = shouldBeDefault;
        return this;
    }
    /**
     * Determines if this theme is the default for its color
     * scheme.
     */
    isDefault() {
        return this._default;
    }
    /*
    |--------------------------------------------------------------------------
    | Color Schemes
    |--------------------------------------------------------------------------
    */
    /**
     * Defines the color scheme of this theme.
     */
    setColorScheme(colorScheme) {
        this._colorScheme = colorScheme;
        return this;
    }
    /**
     * Gets the color scheme of this theme.
     */
    getColorScheme() {
        return this._colorScheme;
    }
    /**
     * Determines if the theme is for a light scheme.
     */
    isLight() {
        return color_1.ColorScheme.Light === this._colorScheme;
    }
    /**
     * Determines if the theme is for a dark scheme.
     */
    isDark() {
        return color_1.ColorScheme.Dark === this._colorScheme;
    }
    /**
     * Determines if the theme has no color scheme.
     */
    hasNoScheme() {
        return !this.hasScheme();
    }
    /**
     * Determines if the theme has a color scheme.
     */
    hasScheme() {
        return color_1.ColorScheme.Undefined !== this._colorScheme;
    }
    /**
     * Sets this theme's color scheme to light.
     */
    light() {
        this.setColorScheme(color_1.ColorScheme.Light);
        return this;
    }
    /**
     * Sets this theme's color scheme to dark.
     */
    dark() {
        this.setColorScheme(color_1.ColorScheme.Dark);
        return this;
    }
    /*
    |--------------------------------------------------------------------------
    | Colors
    |--------------------------------------------------------------------------
    */
    /**
     * Adds the given colors to the theme.
     *
     * @param colorObject An object of colors, the same format as Tailwind's, but any TinyColor value can be used.
     */
    addColors(colorObject) {
        const colors = flattenColorObject_1.flattenColorObject(colorObject);
        Object.entries(colors).forEach((color) => {
            this.color(...color);
        });
        return this;
    }
    /**
     * Adds a color to the theme.
     *
     * @param name The name of the color. Will be used for class names.
     * @param color
     */
    color(name, color) {
        this._colors.push(new color_1.VariableColor(name, color));
        return this;
    }
    /**
     * Gets all colors in the theme.
     *
     * @param colors A string or an array of color names to filter.
     */
    getColors(colors) {
        if (!colors) {
            return this._colors;
        }
        if (!Array.isArray(colors)) {
            colors = [colors];
        }
        return this._colors.filter((color) => colors === null || colors === void 0 ? void 0 : colors.includes(color.getName()));
    }
    /*
    |--------------------------------------------------------------------------
    | Variants
    |--------------------------------------------------------------------------
    */
    /**
     * Adds the given variants.
     *
     * @param variants A variant object.
     */
    addVariants(variants) {
        // Detects the type of the variant depending of its
        // content, and adds it
        const detectAndAddVariant = (name, value, colors) => {
            // It's a custom one
            if (lodash_1.default.isFunction(value)) {
                return this.addCustomVariant(name, value, colors);
            }
            // It's an opacity one
            if (lodash_1.default.isNumber(value)) {
                return this.addOpacityVariant(name, value, colors);
            }
            // It's a color one
            if (lodash_1.default.isString(value)) {
                return this.addColorVariant(name, value, colors);
            }
            throw new Error(`Unrecoginized variant '${name}' of value '${value}'.`);
        };
        // Loop through the variants
        Object.entries(variants).forEach(([name, value]) => {
            // If it's an object, it's mapped to some colors
            if (isMappedVariant_1.isMappedVariant(value)) {
                return detectAndAddVariant(name, value.variant, value.colors);
            }
            // It's a scalar value
            detectAndAddVariant(name, value);
        });
        return this;
    }
    /**
     * Add the given color variant to a color or a list of colors.
     *
     * @param name The variant name.
     * @param value The variant value.
     * @param colorNames The color name, or list of color names.
     */
    addColorVariant(name, value, colorNames) {
        return this.addVariant(new color_1.ColorVariant(name, value), colorNames);
    }
    /**
     * Add the given opacity variant to a color or a list of colors.
     *
     * @param name The variant name.
     * @param opacity The opacity value.
     * @param colorNames The color name, or list of color names.
     */
    addOpacityVariant(name, opacity, colorNames) {
        return this.addVariant(new color_1.OpacityVariant(name, opacity), colorNames);
    }
    /**
     * Add the given custom variant to a color or a list of colors.
     *
     * @param name The variant name.
     * @param value The variant value.
     * @param colorNames The color name, or list of color names.
     */
    addCustomVariant(name, transformer, colorNames) {
        return this.addVariant(new color_1.CustomVariant(name, transformer), colorNames);
    }
    /**
     * Add the given variant to a color or a list of colors.
     *
     * @param name The variant name.
     * @param colorNames The color name, or list of color names.
     */
    addVariant(variant, colorNames) {
        // If no color name is used, adding to all colors.
        if (!colorNames) {
            colorNames = this._colors.map((color) => color.getName());
        }
        if (!Array.isArray(colorNames)) {
            colorNames = [colorNames];
        }
        // Running through each color name to add the variant to it.
        colorNames.forEach((colorName) => {
            const predicate = (color) => color.getName() === colorName;
            const index = this._colors.findIndex(predicate);
            if (-1 !== index) {
                this._colors[index].setVariant(variant);
            }
            else {
                throw new Error(`Could not find the color '${colorName}' on which to add variant '${variant.getName()}'.`);
            }
        });
        return this;
    }
    /**
     * Get all variants.
     */
    getVariants() {
        return lodash_1.default.flatten(this._colors.map((color) => color.getVariants()));
    }
    /**
     * Get all color variants.
     */
    getColorVariants() {
        return lodash_1.default.flatten(this._colors.map((color) => color.getVariants().filter((variant) => variant.getType() === color_1.VariantType.Color)));
    }
    /**
     * Get all opacity variants.
     */
    getOpacityVariants() {
        return lodash_1.default.flatten(this._colors.map((color) => color.getVariants().filter((variant) => variant.getType() === color_1.VariantType.Opacity)));
    }
    /**
     * Get all custom variants.
     */
    getCustomVariants() {
        return lodash_1.default.flatten(this._colors.map((color) => color.getVariants().filter((variant) => variant.getType() === color_1.VariantType.Custom)));
    }
    /*
    |--------------------------------------------------------------------------
    | Variables
    |--------------------------------------------------------------------------
    */
    /**
     * Adds an arbitrary variable to the theme.
     *
     * @param name The name of the variable.
     * @param value The value of the variable.
     * @param path An optional path to a Tailwind configuration key.
     * @param prefix An optional prefix to be appended to the variable name.
     */
    setVariable(name, value, path, prefix) {
        this._variables.push(new variable_1.Variable(name, value, path, prefix));
        return this;
    }
    /**
     * Gets every variable.
     */
    getVariables() {
        return this._variables;
    }
}
exports.Theme = Theme;
